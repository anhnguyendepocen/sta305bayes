---
title: "M√©thodes d'√©chantillonnage directes"
linktitle: "√âchantillonnage direct"
date: "2020-11-30"
read_date: "2020-12-03"
menu:
  cours:
    parent: "III Calcul num√©rique pour l'analyse bay√©sienne"
    weight: 2
type: docs
bibliography: "../../static/bib/references.bib"
csl: "../../static/bib/chicago-fullnote-bibliography-no-bib.csl"
slides: "01-slides"
output:
  blogdown::html_page:
    toc: true
---


<div id="TOC">
<ul>
<li><a href="#g√©n√©ration-de-nombres-al√©atoires-selon-des-lois-de-probabilit√©-usuelles">G√©n√©ration de nombres al√©atoires selon des lois de probabilit√© usuelles</a></li>
<li><a href="#√©chantillonner-selon-une-loi-d√©finie-analytiquement">√âchantillonner selon une loi d√©finie analytiquement</a></li>
</ul>
</div>

<div id="g√©n√©ration-de-nombres-al√©atoires-selon-des-lois-de-probabilit√©-usuelles" class="section level3">
<h3>G√©n√©ration de nombres al√©atoires selon des lois de probabilit√© usuelles</h3>
<p>Il existe plusieurs mani√®res de g√©n√©rer des nombres dits ‚Äúal√©atoires‚Äù selon des lois connues. La tr√®s grande partie des programmes informatiques ne g√©n√®rent pas des nombres totalement al√©atoires. On parle plut√¥t de nombres pseudo-al√©atoires, qui semblent al√©atoires mais sont en r√©alit√© g√©n√©r√©s selon un processus d√©terministe (qui d√©pend notamment d‚Äôune ‚Äúgraine‚Äù).</p>
<div id="la-distribution-uniforme" class="section level4">
<h4>La distribution uniforme</h4>
<p>Pour g√©n√©rer un √©chantillon pseudo-al√©atoire selon la loi uniforme sur <span class="math inline">\([0;1]\)</span>, on peut donner l‚Äôexemple de l‚Äôalgorithme congruentiel lin√©aire (Lehmer, 1948) :</p>
<div class="Algo">
<ol style="list-style-type: decimal">
<li><p>G√©n√©rer une suite d‚Äôentiers <span class="math inline">\(y_n\)</span> tel que :<br />
<span class="math inline">\(y_{n+1} = ( ay_n + b )\text{ mod. }m\)</span></p></li>
<li><p><span class="math inline">\(x_n = \frac{y_n}{m-1}\)</span></p></li>
</ol>
<p>Choisir <span class="math inline">\(a\)</span>, <span class="math inline">\(b\)</span> et <span class="math inline">\(m\)</span> de mani√®re √† ce que <span class="math inline">\(y_n\)</span> ait une p√©riode tr√®s longue et que <span class="math inline">\((x_1,\dots , x_n)\)</span> puisse √™tre consid√©r√© comme <span class="math inline">\(iid\)</span></p>
</div>
<p><br></p>
<p>o√π <span class="math inline">\(y_0\)</span> est appel√© la ‚Äúgraine‚Äù (<em>seed</em> en anglais). On remarque que l‚Äôon a necessairement <span class="math inline">\(0 \leq y_n \leq m - 1\)</span>. En pratique on prend <span class="math inline">\(m\)</span> tr√®s grand (par exemple <span class="math inline">\(2^{19937}\)</span>, la valeur par d√©faut dans R qui utilise l‚Äôalgorithme Mersenne-Twister). Dans ce cours, on ne va pas plus s‚Äôint√©resser √† la g√©n√©ration de nombre pseudo-al√©toires selon la loi uniforme sur <span class="math inline">\([0;1]\)</span>, il s‚Äôagit d‚Äôun outil que l‚Äôon consid√®re fiable et qui est utilis√© par les diff√©rents algorithmes pr√©sent√©s par la suite.</p>
</div>
<div id="autres-distributions" class="section level4">
<h4>Autres distributions</h4>
<p>Pour √©chantillonner selon la loi binomiale <span class="math inline">\(Bin(n,p)\)</span>, on peut utiliser les <strong>relations entre les diff√©rentes lois usuelles</strong> en partant de <span class="math inline">\(U_i\sim \mathcal{U}_{[0;1]}\)</span>:
<span class="math display">\[\begin{align*}
    Y_i &amp; =\mathbb{1}_{U_i \leq p} \sim \text{Bernoulli}(p),\\
    X &amp; = \sum_{i=1}^n Y_i \sim Bin(n,p)
  \end{align*}\]</span></p>
<p>Pour √©chantillonner selon la loi normale <span class="math inline">\(N(0,1)\)</span>, on peut utiliser l‚Äôalgorithme de Box-M√ºller:<br />
Si <span class="math inline">\(U_1\)</span> et <span class="math inline">\(U_2\)</span> sont 2 variables uniformes <span class="math inline">\([0;1]\)</span> ind√©pendantes, alors
<span class="math display">\[\begin{align*}
    Y_1 &amp; =\sqrt{-2\log U_1}\cos(2\pi U_2)\\
    Y_2 &amp; =\sqrt{-2\log U_1}\sin(2\pi U_2)
  \end{align*}\]</span>
sont ind√©pendantes et suivent chacune la loi normale <span class="math inline">\(N(0,1)\)</span>.</p>
</div>
</div>
<div id="√©chantillonner-selon-une-loi-d√©finie-analytiquement" class="section level3">
<h3>√âchantillonner selon une loi d√©finie analytiquement</h3>
<div id="m√©thode-par-inversion" class="section level4">
<h4>M√©thode par inversion</h4>
<div class="MyDef">
<p><strong>Inverse g√©n√©ralis√©e</strong><br />
Pour une fonction <span class="math inline">\(F\)</span> d√©finie sur <span class="math inline">\(\mathbb{R}\)</span>, on d√©finit son inverse g√©n√©ralis√©e par <span class="math display">\[ F^{-1}(u) = \text{inf}\{x; F(x)&gt;u\}\]</span></p>
</div>
<p><br></p>
<div class="MyProp">
<p>Soit <span class="math inline">\(F\)</span> la fonction de r√©partition d‚Äôune distribution de probabilit√©, et soit <span class="math inline">\(U\)</span> une variable al√©atoire suivant une loi uniforme sur <span class="math inline">\([0;1]\)</span>. Alors <span class="math inline">\(F^{-1}(U)\)</span> d√©finit une variable al√©atoire ayant pour fonction de r√©partition <span class="math inline">\(F\)</span>.</p>
</div>
<p><br></p>
<p>On d√©duit de la propri√©t√© ci-dessus que si l‚Äôon conna√Æt la fonction de r√©partition de la loi selon laquelle on veut simuler, et si l‚Äôon est capable de l‚Äôinverser, alors on peut g√©n√©rer un √©chantillon suivant cette loi √† partir d‚Äôun √©chantillon uniforme sur <span class="math inline">\([0;1]\)</span>.</p>
<div class="Example">
<p>On veut g√©n√©rer un √©chantillon suivant la loi exponentielle de param√®tre <span class="math inline">\(\lambda\)</span><br />
On a la densit√© de la loi exponentielle qui est <span class="math inline">\(f(x) = \lambda exp(-\lambda x)\)</span>, et la fonction de r√©partition (son int√©grale) qui vaut <span class="math inline">\(F(x) = 1-exp(- \lambda x)\)</span>.<br />
Posons <span class="math inline">\(F(x)=u\)</span>. On remarque alors que <span class="math inline">\(x=-\frac{1}{\lambda}\log(1-u)\)</span>.<br />
Si <span class="math inline">\(U\sim \mathcal{U}_{[0;1]}\)</span>, alors <span class="math inline">\(X=F^{-1}(U)\sim Exp(\lambda)\)</span>.</p>
</div>
<p><br></p>
</div>
<div id="m√©thode-dacceptation-rejet" class="section level4">
<h4>M√©thode d‚Äôacceptation-rejet</h4>
<p>La m√©thode d‚Äôacceptation-rejet consiste √† utiliser une loi instrumentale <span class="math inline">\(g\)</span>, dont on sait √©chantillonner selon la loi, afin d‚Äô√©chantillonner selon la loi cible <span class="math inline">\(f\)</span>. Le principe g√©n√©ral est de choisir <span class="math inline">\(g\)</span> proche de <span class="math inline">\(f\)</span> et de proposer des √©chantillons selon <span class="math inline">\(g\)</span>, d‚Äôen accepter certains et d‚Äôen rejeter d‚Äôautres afin d‚Äôobtenir un √©chantillon suivant la loi de <span class="math inline">\(f\)</span>.</p>
<p><img src="/cours/11-echantillondirect_files/figure-html/Acceptationrejet-1.png" width="576" style="display: block; margin: auto;" /></p>
<div class="Algo">
<p>Soit une loi d‚Äôint√©r√™t de densit√© <span class="math inline">\(f\)</span>.<br />
Soit une loi de proposition de densit√© <span class="math inline">\(g\)</span> (√† partir de laquelle on sait √©chantillonner) telle que, pour tout <span class="math inline">\(x\)</span> :
<span class="math display">\[f(x) \leq Mg(x)\]</span>
Pour <span class="math inline">\(i=1, \dots, n\)</span> :</p>
<ol style="list-style-type: decimal">
<li><p>G√©n√©rer <span class="math inline">\(x_i\sim g\)</span> et <span class="math inline">\(u_i\sim \mathcal{U}_{[0;1]}\)</span></p></li>
<li><p>Si <span class="math inline">\(u_i\leq\frac{f(x_i)}{Mg(x_i)}\)</span> on <strong>accepte</strong> le tirage:<br />
<span class="math inline">\(y_i := x_i\)</span><br />
sinon on le <strong>rejette</strong> et on retourne en 1.</p></li>
</ol>
<p><span class="math inline">\((y_1, \dots, y_n) \overset{iid}{\sim}f\)</span></p>
</div>
<p><br></p>
<p>Plus <span class="math inline">\(M\)</span> est petit, plus le taux de rejet est faible et plus l‚Äôalgorithme est efficace (au sens o√π il n√©cessite moins d‚Äôit√©rations pour obtenir un √©chantillon de taille <span class="math inline">\(n\)</span>). On a donc int√©r√™t √† choisir <span class="math inline">\(g\)</span> le plus proche possible de <span class="math inline">\(f\)</span>, en particulier lorsque la dimension augmente (l‚Äôimpact de <span class="math inline">\(M\)</span> √©tant d‚Äôautant plus important alors). N√©anmoins, la loi de proposition aura n√©cessairement des queues plus lourdes que la loi cible, et ce dans toutes les dimensions de l‚Äôespace des param√®tres. √Ä cause du fl√©au de la dimension, lorsque le nombre de param√®tres augmente, le taux d‚Äôacceptation d√©croit tr√®s rapidement. </p>
<div class="Exercise">
<p>üëâ  <em>Exercice</em> <em>1</em> : Construire un pseudo-√©chantillon de taille <span class="math inline">\(n\)</span> selon la loi discr√®te suivante (multinomiale √† <span class="math inline">\(m\)</span> √©l√©ments <span class="math inline">\(\{x_1, \dots, x_m\}\)</span>) :
<span class="math display">\[P(X=x) = p_1\delta_{x_1}(x) + p_2\delta_{x_2}(x) + \dots p_m\delta_{x_m}(x) \quad \text{ avec }\sum_{i=1}^m p_i = 1  \text{ et } \delta_{a}(x) = \mathbb{1}_{\{x=a\}}\]</span></p>
</div>
<div class="Correction">
<div class="Algo">
<p>Pour <span class="math inline">\(i = 1, \dots, n\)</span> :</p>
<ol style="list-style-type: decimal">
<li>√©chantillonner selon la loi uniforme : <span class="math inline">\(u_i \sim U_{[0,1]}\)</span></li>
<li><span class="math inline">\(y_i := x_{\min\left\{j ; u_i \in [0 ; \sum_{l=1}^j p_l]\right\}}\)</span></li>
</ol>
<p><span class="math inline">\((y_1,\dots, y_n\)</span>) est alors un pseudo-√©chantillon de taille <span class="math inline">\(n\)</span> de la loi <span class="math inline">\(Mult(p_1, \dots, p_m)\)</span></p>
</div>
</div>
<p><br></p>
<div class="Exercise">
<p>üëâ  <em>Exercice</em> <em>2</em> : Gr√¢ce √† la m√©thode par inversion, g√©n√©rer un pseudo-√©chantillon de taille suivant une loi de Cauchy (dont la densit√© est <span class="math inline">\(f(x)=\frac{1}{\pi(1+x^2)}\)</span>), sachant que <span class="math inline">\(\arctan&#39;(x)=\frac{1}{(1+x^2)}\)</span> et que <span class="math inline">\(\underset{x\rightarrow-\infty}{\lim} arctan(x) = -\frac{\pi}{2}\)</span>.</p>
</div>
<div class="Correction">
<p><span class="math inline">\(F(y) = \int_{-\infty}^y f(x)\text{d}x\)</span></p>
<p>Alors <span class="math inline">\(F(x) = \dfrac{\arctan(x)}{\pi +1/2}\)</span>, et il suit que <span class="math inline">\(F^{-1}(x) = \tan\left(\pi(x-1/2)\right)\)</span>.</p>
<p>Donc <span class="math inline">\(Y = \tan\left(\pi(U-1/2)\right) \sim \text{Cauchy}\)</span> (avec <span class="math inline">\(U \sim U_{[0,1]}\)</span>), et on en d√©duit l‚Äôalgorithme suivant :</p>
<div class="Algo">
<p>Pour <span class="math inline">\(i = 1, \dots, n\)</span> :</p>
<ol style="list-style-type: decimal">
<li>√©chantillonner selon la loi uniforme : <span class="math inline">\(u_i \sim U_{[0,1]}\)</span></li>
<li><span class="math inline">\(y_i := \tan\left(\pi(u_i-1/2)\right)\)</span></li>
</ol>
<p><span class="math inline">\((y_1,\dots, y_n\)</span>) est alors un pseudo-√©chantillon de taille <span class="math inline">\(n\)</span> de la loi de Cauchy</p>
</div>
</div>
<p><br></p>
<div class="Exercise">
<p>üëâ  <em>Exercice</em> <em>3</em> : √âcrire un algorithme d‚Äôacceptation-rejet pour simuler la r√©alisation d‚Äôun pseudo-√©chantillon de taille <span class="math inline">\(n\)</span> d‚Äôune loi normale <span class="math inline">\(N(0,1)\)</span> en utilisant une loi de Cauchy comme proposition. Trouvez la valeur de <span class="math inline">\(M\)</span> optimale.</p>
</div>
<div class="Correction">
<p><span class="math inline">\(f(x) = \dfrac{\exp(-x^2/2)}{\sqrt{2\pi}}\)</span> et <span class="math inline">\(g(x) = \dfrac{1}{\pi(1+x^2)}\)</span></p>
<p>On cherche <span class="math inline">\(M\)</span> le plus petit possible tel que <span class="math inline">\(M \geq \dfrac{f(x)}{g(x)} \,\forall\, x\)</span>.</p>
<p>En d√©rivant <span class="math inline">\(\dfrac{f(x)}{g(x)}\)</span>, on trouve <span class="math inline">\(\max\left(\dfrac{f(x)}{g(x)}\right)\)</span> pour <span class="math inline">\(x=-1\)</span> ou <span class="math inline">\(x=1\)</span> (la d√©riv√©e s‚Äôannule en -1,0, et 1). Donc <span class="math inline">\(\dfrac{f(x)}{g(x)}\leq \sqrt{\dfrac{2\pi}{e}}\)</span></p>
<p>On va donc utiliser : <span class="math inline">\(M = \sqrt{\dfrac{2\pi}{e}}\)</span></p>
<pre class="r"><code>f &lt;- function(x){
  exp(-x^2/2)/sqrt(2*pi)
}
g &lt;- function(x){
  1/(pi*(1+x^2))
}
x &lt;- seq(from = -10, to = 10, by = 0.01)
plot(x=x, y=f(x)/g(x), type=&#39;l&#39;, lwd = 2, ylab=&quot;Densit√© de probabilit√©&quot;)
lines(x = x, y=f(x), type = &quot;l&quot;, lwd = 2, col=&quot;red&quot;)
lines(x = x, y=g(x), type = &quot;l&quot;, lwd = 2, col=&quot;blue&quot;)
lines(x = x, y=g(x)*sqrt(2*pi/exp(1)), type = &quot;l&quot;, lwd = 1.5, lty=3, col=&quot;purple&quot;)
legend(&quot;topleft&quot;, legend = c(&quot;f(x)&quot;, &quot;g(x)&quot;, &quot;f(x)/g(x)&quot;, &quot;M*g(x)&quot;), col=c(&quot;red&quot;, &quot;blue&quot;, &quot;black&quot;, &quot;purple&quot;), lwd=c(2, 2, 2, 1.5), lty=c(1, 1, 1, 3))</code></pre>
<p><img src="/cours/11-echantillondirect_files/figure-html/unnamed-chunk-1-1.png" width="672" /></p>
</div>
</div>
</div>
